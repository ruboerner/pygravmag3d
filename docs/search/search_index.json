{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pygravmag3d","text":"<p>3D gravity and magnetic modelling using a triangulated surface mesh.</p>"},{"location":"#installation","title":"Installation","text":"<p>Clone the repository and install:</p> <pre><code>pip install .\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the examples in the README.md for a quick start.</p>"},{"location":"#api-documentation","title":"API documentation","text":"<p>See the API for details.</p>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#pygravmag3d.get_h.get_H","title":"<code>get_H(Face, cor, Un, M, density)</code>","text":"<p>Magnetic and gravity anomaly at the origin due to a polyhedral body of homogeneous magnetization and density.</p>"},{"location":"reference/#pygravmag3d.get_h.get_H--parameters","title":"Parameters","text":"<p>Face : (nf, 3) int array     Triangle indices (1-based in original MATLAB; provide 0-based here). cor : (nc, 3) float array     Vertex coordinates (meters). Un : (nf, 3) float array     Unit normals of the triangular faces (outward). M : (3,) float array     Magnetization vector (A/m). density : float     Mass density (kg/m^3).</p>"},{"location":"reference/#pygravmag3d.get_h.get_H--returns","title":"Returns","text":"<p>Bx, By, Bz, gx, gy, gz : floats     Magnetic flux density components Bx, By, Bz      (same unit as the main field provided in the calling function)      and gravitational acceleration     components gx, gy, gz (in m/s^2) at the origin.</p> Source code in <code>pygravmag3d/get_h.py</code> <pre><code>def get_H(Face, cor, Un, M, density):\n    \"\"\"\n    Magnetic and gravity anomaly at the origin due to a polyhedral body\n    of homogeneous magnetization and density.\n\n    Parameters\n    ----------\n    Face : (nf, 3) int array\n        Triangle indices (1-based in original MATLAB; provide 0-based here).\n    cor : (nc, 3) float array\n        Vertex coordinates (meters).\n    Un : (nf, 3) float array\n        Unit normals of the triangular faces (outward).\n    M : (3,) float array\n        Magnetization vector (A/m).\n    density : float\n        Mass density (kg/m^3).\n\n    Returns\n    -------\n    Bx, By, Bz, gx, gy, gz : floats\n        Magnetic flux density components Bx, By, Bz \n        (same unit as the main field provided in the calling function) \n        and gravitational acceleration\n        components gx, gy, gz (in m/s^2) at the origin.\n    \"\"\"\n    Face = np.asarray(Face, dtype=int)\n    cor = np.asarray(cor, dtype=float)\n    Un = np.asarray(Un, dtype=float)\n    M = 1e-7 * np.asarray(M, dtype=float).reshape(3)\n\n    Hx = Hy = Hz = 0.0\n    gx = gy = gz = 0.0\n\n    # Scale for gravity\n    rhof = density * G\n\n    # If Face appears to be 1-based (MATLAB), convert to 0-based\n    if Face.min() == 1:\n        Face = Face - 1\n\n    nf = Face.shape[0]\n\n    for i in range(nf):\n        # Triangle vertices (columns), observation at origin\n        idx = Face[i]\n        V = cor[idx, :].T  # shape (3,3), columns are P,Q,R\n\n        # Solid angle of the face\n        Omega = tri_angle(V[:, 2], V[:, 1], V[:, 0])\n        N = Un[i, :]\n        # Adjust sign depending on orientation\n        di = np.dot(V[:, 0], N)\n        if di &lt; 0:\n            Omega = -np.sign(di) * Omega\n\n        # Edge integral vector for the triangle\n        PQR = get_pqr(V)  # (p, q, r)\n\n        # Face unit normal\n        N = Un[i, :].astype(float)\n        l, m, n = N\n\n        p, q, r = PQR\n\n        # Field-shape combinations\n        hx = l * Omega + n * q - m * r\n        hy = m * Omega + l * r - n * p\n        hz = n * Omega + m * p - l * q\n\n        # Magnetic contribution (Pd = N \u00b7 M)\n        Pd = float(np.dot(N, M))\n        Hx += Pd * hx\n        Hy += Pd * hy\n        Hz += Pd * hz\n\n        # Gravity contribution: multiply shape by G * density\n        di = rhof * di\n        gx -= di * hx\n        gy -= di * hy\n        gz -= di * hz\n\n    return Hx, Hy, Hz, gx, gy, gz\n</code></pre>"},{"location":"reference/#pygravmag3d.get_triangulation.get_triangulation","title":"<code>get_triangulation(pts)</code>","text":"<p>Compute the outward-oriented triangular surface mesh of the convex hull of <code>pts</code>.</p>"},{"location":"reference/#pygravmag3d.get_triangulation.get_triangulation--parameters","title":"Parameters","text":"<p>pts : ndarray of shape (n_points, 3)     Cartesian coordinates of the points defining the body.</p>"},{"location":"reference/#pygravmag3d.get_triangulation.get_triangulation--returns","title":"Returns","text":"<p>faces_oriented : ndarray of shape (n_faces, 3)     Indices of the hull vertices, oriented so their winding follows the outward normal. cor : ndarray of shape (n_points, 3)     Coordinates of the hull vertices ordered consistently with <code>faces_oriented</code>. Un : ndarray of shape (n_faces, 3)     Unit outward normal vector for each triangular face. v : float     Volume enclosed by the convex hull.</p> Source code in <code>pygravmag3d/get_triangulation.py</code> <pre><code>def get_triangulation(pts):\n    \"\"\"\n    Compute the outward-oriented triangular surface mesh of the convex hull of `pts`.\n\n    Parameters\n    ----------\n    pts : ndarray of shape (n_points, 3)\n        Cartesian coordinates of the points defining the body.\n\n    Returns\n    -------\n    faces_oriented : ndarray of shape (n_faces, 3)\n        Indices of the hull vertices, oriented so their winding follows the outward normal.\n    cor : ndarray of shape (n_points, 3)\n        Coordinates of the hull vertices ordered consistently with `faces_oriented`.\n    Un : ndarray of shape (n_faces, 3)\n        Unit outward normal vector for each triangular face.\n    v : float\n        Volume enclosed by the convex hull.\n    \"\"\"\n    hull = ConvexHull(pts)\n    Face = hull.simplices  # shape (F,3), 0-based indexing\n    cor = hull.points\n    v = hull.volume\n    equations = hull.equations  # each row: [a,b,c,d] outward plane\n\n    faces_oriented = Face.copy()\n    Un = np.zeros((Face.shape[0], 3))\n\n    for i, tri in enumerate(Face):\n        A, B, C = pts[tri]\n        n_geom = np.cross(B - A, C - A)\n        n_geom /= np.linalg.norm(n_geom)\n\n        # Outward normal from Qhull\u2019s plane\n        n_out = equations[i, :3]\n        n_out /= np.linalg.norm(n_out)\n\n        # If they point in opposite directions, flip triangle winding\n        if np.dot(n_geom, n_out) &lt; 0:\n            faces_oriented[i, [1, 2]] = faces_oriented[i, [2, 1]]\n            n_geom = -n_geom\n\n        Un[i] = n_geom   # consistent outward unit normal\n\n    return faces_oriented, cor, Un, v\n</code></pre>"}]}